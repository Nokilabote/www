---
title: "Introduction to OS/161"
spelling_exceptions:
  - PPA
---
:sectnums:

== Introduction

[.lead]
ASST0 introduces you to the codebase and tools that you will be using
throughout the rest of the `ops-class.org` assignments.

It is unlikely that you have used OS/161 before, but some of the
other tools may be familiar to you:

* http://os161.eecs.harvard.edu[*OS/161*]: OS/161 includes both
. the sources of the the operating system you will be designing,
implementing, running and debugging, and
. a toolchain for cross compiling and running your kernel, including a
machine simulator called `sys161` footnote:[Also known as System/161].
* https://git-scm.com/[*Git*]: a distributed source control tools that
tracks your changes to OS/161 and enables effective collaboration.
* https://www.gnu.org/software/gdb/[*GDB*]: the GNU debugger which allows you
to control and inspect your running system.
  
=== Objectives

After completing ASST0 you should:

. Have set up your OS/161 development environment.
. Understand the source code structure of OS/161.
. Be comfortable navigating the OS/161 sources to determine where and how
things are done.
. Have been introduced to Git and GDB.
. Be able to, modify, build and run your first OS/161 kernel.

=== A Note on Cut-and-Paste

Another assignment objective is to get you up to speed working efficiently in
a Linux development environment using standard command-line development
tools. Earlier versions of this assignment had come to contain a lot of
cut-and-paste snippets that students could run from the command line. While
students found this helpful, we have decided to remove many of these
instructions and provide direction in English text instead. This is for the
simple reason that too many students were simply skimming the assignment text
while cutting and pasting the relevant sections into their terminal.

Unlike many of the things you will find online ASST0 is _not a tutorial._ You
will go slower, but you will learn a lot more from figuring out how to:
"Run the first OS/161 thread test and then shut down your kernel" than how
to:
[source,bash]
----
trinity@zion:~$ sys161 kernel "tt1;q"
----

Following these kinds of written instructions will also better prepare you to
interact with other OS/161 hackers in person and in the online forum.

=== A Note on Learning Git

Another objective of this course is to help you learn to use common
development tools, particularly Git. However, like most programming tools the
best way to get started with and continue to learn Git is through the
extensive online documentation and multiple good online tutorials.

As a result, we have removed Git guides from the `ops-class.org`
documentation. Not only is any documentation we could provide much less
likely to be complete and up-to-date, but this will provide you with good
practice in online learning. Feel free to ask your course staff or other
students for help, either in person or using the online forum. Chances are
many of them use Git or something similar on a daily basis. When you become a
professional hacker, you will too.

Like anything else, learning Git takes practice and patience. But here's one
simple tip: *read the output and error messages generated by Git commands.*
Git produces remarkably useful output, particularly when an error occurs or
when it hasn't accomplished what you asked. Frequently the output tells you
_exactly_ what to do to address whatever issue you are facing, down to the
commands that you should type.

=== Collaboration Guidelines

ASST0 focuses on getting your environment set up and asking you to begin
familiarizing yourself with the OS/161 source you will be modifying. There is
a small amount of coding involved, but not too much. While the assignment is
ungraded, here are the guidelines for how to work together and work with your
partner (if you have one):

TIP: Working side-by-side with your partner on ASST0 is *strongly
encouraged*.
  
TIP: Helping other students set up their `ops-class.org` environment is
encouraged.
    
TIP: Helping each other with Git is encouraged.
    
TIP: Discussing the code reading questions and browsing the source code with
other students is encouraged.
    
WARNING: Dividing the code reading questions and development tasks between
partners is discouraged.
  
CAUTION: Copying any answers from anyone who is not your partner or anywhere
else and submitting them as your own is cheating.
  
CAUTION: You may not refer to or incorporate any external sources without
explicit permission footnote:[Which you are extremely unlikely to get.].
  
== Choosing and Initializing Your Development Environment

[.lead]
Developing for OS/161 requires a specialized set of tools, including the
`sys161` simulator along with a GCC cross-compiler allowing you to create
MIPS r3000 binaries that `sys161` can execute.

We support three options allowing you to access the OS/161 toolchain. You
can:

. install the toolchain natively on your own Ubuntu machine,
. run a Ubuntu virtual machine that has the toolchain installed as a guest on
a Windows or Mac host,
. or use a toolchain that has been pre-installed on a shared machine accessible
via SSH.

Each option is described in more detail below. However, #1 requires access to
a computer running Ubuntu Linux, which you may or may not have. If you run
Mac or Windows, #2 or #3 are your best options. And if your course staff has
set up a shared machine for you, #3 is a very straightforward choice. That
said, there are other tradeoffs to each choice, so we suggest that you read
through your options carefully before making a decision.

=== Ubuntu Host

If you have a computer running Ubuntu Linux, we have packaged the OS/161
toolchain for the last two Ubuntu [.spelling_exception]#LTS# releases (12.04
Precise and 14.04 Trusty) in a Launchpad PPA. Installation is simple:

[source,bash]
----
sudo add-apt-repository ppa:geoffrey-challen/os161-toolchain
sudo apt-get update
sudo apt-get install os161-toolchain
----

If you don't have a computer running Linux, and you have a spare computer
around, you may want to give Ubuntu a try. Maintaining your own Linux machine
is a great way to learn more about system administration and, to some degree,
about operating systems as well.

=== Ubuntu Guest Using Vagrant

If you'd prefer to develop on your own machine but don't run Ubuntu Linux, we
have a Vagrant configuration allowing you to easily fire up a VirtualBox
guest virtual machine on your Windows or Mac host footnote:[We'll talk a lot
more about virtualization in class, but here's one example of how useful it
can be.].

The first step is to install https://www.vagrantup.com/[Vagrant], which
happily comes with installers for most common operating systems. Next you
need to get our `Vagrantfile` which describes how to provision and configure
your virtual machine. You'll need Git installed to complete this next step.
Pick or create an empty directory to use for your OS/161 sources. Then clone
our Vagrant repository into that directory.

Once that's done, you should be able to run `vagrant up` from the directory
containing our `Vagrantfile`. Note that `vagrant up` will take a few minutes
to complete the first time, and you need to be online so that Vagrant can
download various external resources:

[source,bash]
----
vagrant up # This may take a few minutes
----

Assuming `vagrant up` completes successfully, you should be able to log in to
your running virtual machine and run the OS/161 tools:

[source,bash]
----
$ vagrant ssh
trinity@zion:~$ sys161
sys161: System/161 release 2.0.6, compiled Dec 23 2015 21:58:13
sys161: Usage: sys161 [sys161 options] kernel [kernel args...]
...
----

By default our configuration shares the `src` subdirectory of the directory
where you installed our `Vagrantfile` with the virtual machine, meaning that
you can edit your OS/161 source code either inside or outside of the virtual
machine. Given that by default our VM does not have a GUI, if you prefer a
graphical source code editor you may want to edit your code using tools
installed on the host. However, you need to be logged in to your VM to
compile and run your OS/161 kernel.

If you are having trouble, make sure that all Vagrant commands (`vagrant up`,
`vagrant ssh`, etc.) are run from the same directory as the `Vagrantfile` you
created previously. That's just how Vagrant works.

=== Preexisting External Installation

You may have access to a shared machine with the OS/161 toolchain installed,
allowing you to work remotely over SSH. While this is by far the easiest
option, it does limit your ability to work offline and may affect your choice
of source code editor.
 
=== Do-It-Yourself Installation on Other Flavors of UNIX

We don't support this option, but if you'd like to try instructions are
available at the http://os161.eecs.harvard.edu[OS/161 website]. You will need
to download, configure, compile and install from the OS/161 toolchain
sources. Linux and other UNIX variants are likely to work. Superheroes have
gotten things to work on OSX. Please use the most recent version of the
cross-compilation toolchain and System/161.

== Configuring, Building, and Running on OS/161 Kernel

[.lead]
Now that you have your development environment ready, on to the fun stuff:
building and booting your first OS/161 kernel.

=== Download the OS/161 Source Code

We distribute the OS/161 source code using Git. Starting with a clone of our
repository makes it easy for us to distribute updates, bug fixes, and new
OS/161 releases, which can be merged easily into your development repository.

First, choose a directory to work in:

* If you are using our Vagrant virtual machine,
you can run Git either inside or outside of your virtual machine, assuming
your host machine has Git installed. For simplicity, we suggest cloning the
sources inside your virtual machine in `/home/trinity/src`, which should be
an empty directory.
* If you have the toolchain installed natively you can create your source
directory wherever you want.

Let's say you've chosen a directory called `src`, which should either not
exist or (in the case of the Vagrant VM) be empty. Clone
https://gitlab.ops-class.org/staff/os161[our `ops-class.org` Git repository]
into that directory. *Note that a simple `git clone` will not do the right
thing.* Take a look at the man page for `git clone` or peruse the help output
to make sure you get it right.

=== Configure Your OS/161 Source Tree

The next step is to configure the OS/161 sources by running the `configure`
command located at the root of your source tree. You need to do this (very
short) step only when you completely remove your source tree for some reason.
The only configuration step is to set up where various binaries--including
system executable and your kernel--will be created when you run `make` in
later steps. Run `configure -help` to find out more including available
command line options.

Note that by default OS/161 installs things to `$HOME/os161/root`, which is a
fine plan to put things if you are working on a shared machine. For our
dedicated VM we use `$HOME/root` to shorten the directory paths a bit, but
this requires that you use the `--ostree` argument to `configure`. If you
forget this argument either now or when you need to rerun `configure` later,
you will install things into `$HOME/os161/root`. *This has caused confusion
for some students previously, so please be careful.*

=== Configure Your OS/161 Kernel

The kernel sources for OS/161 are in the `kern` subdirectory, which has its
own configuration script. Change into `kern/conf` and look around. You should
notice a configuration script, a base configuration file (`kern.conf`), and
four configurations that include `kern.conf`.

You should take a look at `kern.conf` and one of the configurations to get a
sense of the format. But for now, the only thing we're concerned about is
ensuring that we enable `dumbvm` for `ASST0`. You're going to write a
full-fledged virtual memory (VM) system in `ASST3`, but for the first few
assignments `dumbvm` provides enough of a "dumb" VM to allow you to proceed.
Configure a kernel now with `dumbvm` enabled.

The OS/161 kernel configuration process sets various options that control how
your kernel gets built, so unlike the configuration step above you will
probably need to modify these files at some point during later assignments.
In particular, `conf.kern` determines what source files get included in your
kernel build, so if you add sources to the kernel you'll need to add them to
`conf.kern` as well.

=== Build Your OS/161 Kernel

Once you're successfully configured your OS/161 kernel you should have a
directory to compile in, as well as a reminder about a build step that you
might forget. Once you change into that directory you are ready to build a
kernel!

One important note before you start. You are probably used to using
https://www.gnu.org/software/make/[GNU `make`] to build software on UNIX-like
systems. However, the OS/161 sources use
http://www.crufty.net/help/sjg/bmake.htm[BSD `make`], which has a different
`Makefile` syntax footnote:[Why? Because David Holland is a big
http://www.netbsd.org/[NetBSD] hacker.]. To avoid confusion, BSD `make` has
been installed on your system as `bmake`. So while you might normally run
`make clean` to reset your build and remove all of the build targets, when
working with OS/161 you would run `bmake clean`.

There are three steps:

. *Building the dependencies (`bmake depend`)*. This scans all of the source
files that you have configured to be part of your kernel and ensures that all
their header files are also included.
. *Building the kernel (`bmake`)*. This generates your kernel binary.
. *Installing the kernel (`bmake install`)*. This installs your kernel into
the root directory that you configured above.

Run these three commands now and check that they complete successfully. Then
change into your root directory and look around. You should see a fresh
kernel. If you don't, review the steps above until your kernel builds
successfully.

=== Configuring `sys161`
 
Now that you have a kernel, the next step is to run it. But how? Given that
your kernel doesn't yet have any useful features, it would be impossible to
use it to run an actual computer, or even in a fully-featured virtual machine
like VirtualBox.

Instead, OS/161 kernels are built to be run by a special-purpose system
simulator called `sys161`, or System/161. Compared to other virtual machines
or full-system simulators, `sys161` is much simpler and faster but retains
enough realism to enable kernel development using OS/161. degree of realism.
Apart from floating point support and certain issues relating to RAM cache
management, it provides an accurate emulation of a MIPS processor
footnote:[If you'd like to know more about System/161 and OS/161,
http://www.eecs.harvard.edu/~syrah/papers/sigcse-02/sigcse-02.pdf[this paper]
provides an excellent overview.].

Unlike OS/161, we _do not_ expect you to modify `sys161`. However, you do
need to _configure_ the simulated machine that `sys161` provides by choosing
the number of simulated CPU cores, the amount of simulated memory, and the
number of simulated disk drives. Here is a `sys161.conf` file that you can
use to get started. But you should read and understand the structure of this
configuration file so that you can modify it as needed in later assignments.

=== Running Your First Kernel

Now that you have a kernel and a `sys161` configuration file you should be
ready to go. Fire up your kernel and see what happens. Poke around a bit at
the menu. Run a test or two. And then shut down.

What just happened? You ran one computer program (`sys161`) that loaded your
kernel (from the `kernel`) file. Your kernel is itself a program expressed as
a series of MIPS r3000 instructions, which were interpreted by `sys161` and
simulated as if they had executed on real hardware. Of course, this includes
the ability read from and write to a console device, allowing you to interact
with your running kernel.

Examine the output produced by your kernel as it boots and shuts down. You
should be able to answer the following questions:

* Which version of System/161 and OS/161 are you using?
* Where was OS/161 developed and copyrighted?
* How much memory and how many CPU cores was System/161 configured to use?
* What configuration was used by your running kernel?
* How many times has your kernel been compiled?

Before going on try the following exercises:

* Boot your OS/161 kernel with 8 cores.
* Try booting with 256K of memory. What happens?
* Configure System/161 to use a fixed value to initialize its random number
generator. (This can be helpful when debugging non-deterministic kernel
behavior.)

////
== Exploring the OS/161 Codebase

[.lead]
One of the challenges inherent to working with any preexisting codebase,
OS/161 included, is determining what already exists so that you can identify
what you need to add to accomplish some task.

To become familiar with a codebase, there is no substitute for actually
poking around. Browse through the tree a bit to get a sense of how things are
structured. Glance through some source code for files that look interesting.
Admittedly, most code makes poor bedtime reading footnote:[Except perhaps as
a soporific], but it is essential that you read the code. OS/161 is also a
pedagogical codebase and includes a great deal of helpful commentary.

Most of the OS/161 sources are C source (`.c`) and header (`.h`) files. Your
kernel does also contain a bit of assembly code (`.S`) files. You will not
need to understand or modify the assembly code, but it does contain some
fairly interesting pieces of code executed at bootup and during context
switches. So you may want to take a look at it at some point. It is also
_extremely_ well commented footnote:[Thanks
http://www.hcs.harvard.edu/~dholland/[David]!]

=== Where to Start

You should use the code reading questions below to guide an initial
exploration of the OS/161 codebase. While the questions won't require you
look at every line of code or even every file, we _strongly recommend_ that
you at least glance at all the kernel sources in the `kern` subdirectory.

Some parts of the code may seem confusing since we have not discussed how any
OS/161 subsystems work. However, it is still useful to review the code now
and get a high-level idea of what is happening in each subsystem. If you do
not understand the low-level details now, that is fine.

==== Top-level directory structure

The top-level directory contains the following files and subdirectories:

. `configure`: the top-level configuration script that configures the OS/161
distribution. Note that it does *not* configure your OS/161 kernel, which is
done separately and discussed in more detail below. The most important option
to `configure` is `--ostree`, which sets the root directory there your kernel
and user space binaries will be installed.
. `Makefile`: top-level `Makefile`. Running `bmake` in this directory
builds and installs the user space binaries but not the OS kernel.
    including all the provided user-space utilities, but does not build the operating 
    system kernel. (If you don't know anything about <kbd>make</kbd>, this
    would be a good time to at least review the
    <a href="http://mrbook.org/tutorials/make/">basics</a>.)</li>
    OS/161 distribution, including all the provided utilities, but does not
    configure the operating system kernel.</li>
  <h4>The top-level directory</h4>

  <p>The top level directory of many software packages is called
  <kbd>src</kbd> or <kbd>source</kbd>. The top of the OS/161 source tree is
  also called <kbd>src</kbd>. In this directory, you will find the following
  files:</p>
  
  <ul>
    <li><kbd>configure</kbd>: top-level configuration script; configures the
    OS/161 distribution, including all the provided utilities, but does not
    configure the operating system kernel.</li>
    <li><kbd>Makefile</kbd>: top-level makefile; builds the OS/161 distribution, 
    including all the provided utilities, but does not build the operating 
    system kernel. (If you don't know anything about <kbd>make</kbd>, this
    would be a good time to at least review the
    <a href="http://mrbook.org/tutorials/make/">basics</a>.)</li>
  </ul>

  <p>You will also find the following directories:</p>

  <ul>
    <li><kbd>common/</kbd>: code used both by the kernel and user-level programs,
    mostly standard C library functions.</li>
    <li><kbd>kern/</kbd>: the kernel source code.</li>
    <li><kbd>man/</kbd>: the OS/161 manual ("man pages") appear here.  The man pages 
    document (or specify) every program, every function in the C library, 
    and every system call. You will use the system call man pages for 
    reference in the course of ASST2. The man pages are HTML and can 
    be read with any browser.</li>
    <li><kbd>mk/</kbd>: fragments of makesfiles used to build the system.</li>
    <li><kbd>user/</kbd>: user-level libraries and program code.</li>
    <li><kbd>design:/<kbd>: a few design notes about various parts of
    OS/161.</li>
  </ul>

  <blockquote class="aside">
  <p>OS/161 borrows its directory structure from BSD UNIX. Why? See note
  above about David Holland being a big BSD hacker.</p>
  </blockquote>

  <p>In the <kbd>user/</kbd> directory, you will find:</p>
  
  <ul>
    <li><kbd>bin/</kbd>: all the utilities that are typically found in
    <kbd>/bin/</kbd>&mdash;<kbd>cat</kbd>, <kbd>cp</kbd>, <kbd>ls</kbd>, etc.
    Programs in <kbd>/bin/</kbd>
    are considered fundamental utilities that the system needs to run.</li>
    <li><kbd>include/</kbd>: these are the include files that you would typically find 
    in <kbd>/usr/include</kbd> (in our case, a subset of them).  These are user 
    level include files; not kernel include files.</li>
    <li><kbd>lib/</kbd>: library code lives here.  We have only two libraries: 
    <kbd>libc</kbd>, the C standard library, and <kbd>hostcompat</kbd>, which is 
    for recompiling OS/161 programs for the host UNIX system.  There is also 
    a <kbd>crt0</kbd> directory, which contains the startup code for user
    programs.</li>
    <li><kbd>sbin/</kbd>: this is the source code for the utilities typically found in 
    <kbd>/sbin</kbd> on a typical UNIX installation. In our case, there are 
    some utilities that let you halt the machine, power it off andreboot it, 
    among other things.</li>
    <li><kbd>testbin/</kbd>: these are pieces of test code that we will use to
    test and grade your assignments.</li>
  </ul>

  <blockquote class="aside">
  <p>if you have ever wondered why some programs on your system are in
  <kbd>/bin/</kbd> while others are in <kbd>/usr/bin</kbd> or other places,
  <a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">this
  email</a> sheds some light on the split.</p>
  </blockquote>

  <p> You don't need to understand the files in <kbd>user/bin/</kbd>,
  <kbd>user/sbin/</kbd>, and <kbd>user/testbin/</kbd> now, but you certainly
  will later on. Eventually, you will want to modify these or write your own
  utilities and these are good models.</p>

  <p>Similarly, you need not read and understand everything in
  <kbd>user/lib</kbd> and <kbd>user/include</kbd> but you should know enough
  about what's there to be able to get around the source tree easily.  The
  rest of our code walk-through is going to focus on <kbd>kern/</kbd>.</p>

  <h4>The <kbd>kern/</kbd> subdirectory</h4>

  <p>Once again, there is a <kbd>Makefile</kbd>.  This <kbd>Makefile</kbd>
  installs header files but does not build anything.</p>

  <p>In addition, we have more subdirectories for each component of the
  kernel as well as some utility directories and configuration files.</p>

  <h4><kbd>kern/arch</kbd></h4>

  <p>This is where architecture-specific code goes. By architecture-specific,
  we mean the code that differs depending on the hardware platform on which
  you're running.  There are two directories here: <kbd>mips</kbd> which
  contains code specific to the MIPS processor and <kbd>sys161</kbd> which
  contains code specific to the System/161 simulator.</p>

  <ul>
    <li><kbd>kern/arch/mips/conf/conf.arch</kbd>: this file tells the kernel
    config script where to find the machine-specific, low-level functions it
    needs (throughout <kbd>kern/arch/mips/</kbd>).</li>
  </ul>

  <ul>
    <li><kbd>kern/arch/mips/include/</kbd>: this folder and its subdirectories
    include files for the machine-specific constants and functions.</li>
  </ul>

  {% question "default virtual memory compile option" %}

  <ul>
    <li><kbd>kern/arch/mips/</kbd>: The other directories contain source files for 
    the machine-dependent code that the kernel needs to run.  Most of this code 
    is quite low-level.</li>
  </ul>
  
  {% question "OS/161 registers" %}

  {% question "machine dependent code" %}
  
  <ul>
    <li><kbd>kern/arch/sys161/conf/conf.arch</kbd>: Similar to
    <kbd>mips/conf/conf.arch</kbd>.</li>
    <li><kbd>kern/arch/sys161/include:</kbd> These files are include files for the 
    System161-specific hardware, constants, and functions.
    machine-specific constants and functions.</li>
  </ul>

  {% question "using more than 512MB" %}
  
  <h4><kbd>kern/compile/</kbd></h4>

  <p>This is where you build kernels.  In the compile directory, you
  will find one subdirectory for each kernel you want to build.  In a
  real installation, these will often correspond to things like a debug
  build, a profiling build, etc.</p>

  <p>In our world, each build directory will correspond to a programming
  assignment, e.g., ASST1, ASST2, etc. These directories are created when you
  configure a kernel, which you have just done previously. This directory and
  build organization is typical of UNIX installations and is not universal
  across all operating systems.</p>

  <ul>
    <li><kbd>kern/conf/config</kbd>: is the script that takes a config file, 
    like ASST1, and creates the corresponding build directory.</li>
  </ul>

  <blockquote class="aside"><p>make sure that you should specify the complete
    pathname <kbd>./config</kbd> when you configure OS/161. If you omit the
    <kbd>./</kbd>, you may end up running the configuration command for the system
    on which you are building OS/161, and that is almost guaranteed to produce
    rather strange results!</p></blockquote>

  <h4><kbd>kern/dev/</kbd></h4>

  <p>This is where all the low level device management code is stored.  Unless
  you are really interested, you can safely ignore most of this directory.</p>

  <h4><kbd>kern/include/</kbd></h4>

  <p>These are the include files that the kernel needs.  The <kbd>kern</kbd>
  subdirectory contains include files that are visible not only to the
  operating system itself, but also to user-level programs.  (Think about why
  it's named "kern" and where the files end up when installed.)</p>

  {% question "OS/161 busses" %}
  
  {% question "splx" %}
  
  {% question "explicitly-sized types" %}
  
  {% question "special type definitions" %}
  
  {% question "device driver interface" %}
  
  {% question "adding debug messages" %}
  
  {% question "defined synchronization primitives" %}
 
  {% question "yield v. sleep" %}
  
  {% question "OS/161 version" %}

  <h4><kbd>kern/lib/</kbd></h4>

  <p>These are library routines used throughout the kernel, e.g., arrays,
  kernel printf, etc.</p>

  <h4><kbd>kern/startup/</kbd></h4>

  <p>This is where the kernel is initialized and where the kernel main function
  is implemented.</p>

  <h4><kbd>kern/thread/</kbd></h4>

  <p>Threads are the fundamental abstraction on which the kernel is built. For
  the following questions <em>do not forget to look
    back at header files!</em></p>

  {% question "runnable threads data structure" %}
  
  {% question "provided synchronization primitives" %}
  
  {% question "zombie" %}

  <h4><kbd>kern/synchprobs/</kbd></h4>

  <p>This is the directory that contains the framework code that you will need 
  to complete ASST1. Ignore it for now.</p>

  <h4><kbd>kern/syscall/</kbd></h4>

  <p>This is where you will add code to create and manage user level processes.
  As it stands now, OS/161 runs only kernel threads&mdash;there is no support
  for user level code. (Try running the shell from the OS/161 menu and see what
  happens.) In ASST2, you'll implement this support.</p>

  <h4><kbd>kern/vm/</kbd></h4>

  <p>This directory is also fairly vacant.  In ASST3, you'll implement virtual
  memory and most of your code will go in here.</p>

  {% question "copyin/copyout" %}
  
  {% question "malloc implementations" %}
  
  <h4><kbd>kern/vfs/</kbd></h4>

  <p>The file system implementation has two directories. We'll talk about each
  in turn.  <kbd>kern/vfs</kbd> is the filesystem independent
  layer&mdash;<kbd>vfs</kbd> stands for virtual file system. It establishes a
  framework into which you can add new file systems easily. You will want to go
  look at <kbd>vfs.h</kbd> and <kbd>vnode.h</kbd> before looking at this
  directory.</p>

  {% question "read null:" %}
  
  {% question "cwd lock" %}
  
  <h4><kbd>kern/fs/</kbd></h4>

  <p>This is where the actual file systems go. The subdirectory <tt>sfs</tt>
  contains a simple default file system.</p>

  {% question "vnodes and sfs" %}
  
  <h3>Submit your code reading answers</h3>
  
  <p>When you are satisfied with your answers to the code reading questions, submit them for grading
  using the form below.</p>
  
  {% endform %}
////
